#include"List.cpp"


//========================================================================================



//#define BASE_CHECK
void main()
{
	setlocale(LC_ALL, "");
#ifdef BASE_CHECK
	int n;
	cout << "Введите количество элементов: "; cin >> n;
	List list;
	for (int i = 0; i < n; i++)
	{
		// list.push_front(rand() % 100);
		list.push_back(rand() % 100);
	}
	list.print();

	/*list.reverse_print();
	for (int i = 0; i < 100; i++)list.pop_back();
	list.reverse_print();*/

	int index;
	int value;
	cout << "Введите индекс добавляемого элемента: "; cin >> index;
	cout << "Введите значение добавляемого элемента: "; cin >> value;
	list.insert(value, index);
	list.print();
	//list.reverse_print();

	cout << "Введите индекс удаляемого элемента: "; cin >> index;
	list.erese(index);
	list.print();

#endif // BASE_CHECK
	//List list = { 3,5,8,13,21 };
	//list.print(); 
	///*int index;
	//int value;
	//cout << "Введте индекс добавляемого элемента:"; cin >> index;
	//cout << "Введите значение добавляемого элемента:"; cin >> value;
	//list.insert(value, index);
	//list.print();
	//list.reverse_print();*/
	//for (int i : list)cout << i << tab;		cout << endl;
	//for (List::ReverseIterator it = list.rbegin(); it != list.rend();it++)
	//{
	//cout << *it << tab;
	//}
	//
	List<int> list1 = { 3,5,8,13,21 };
	List<int> list2 = { 34,55,89 };
	List<int> list3 = list1 + list2;
	//List list2=list1;
	//list2 = list1;
	/*list2.print();
	list2.reverse_print();*/
	for (int i : list1)cout << i << tab; cout << endl;
	for (int i : list2)cout << i << tab; cout << endl;
	for (int i : list3)cout << i << tab; cout << endl;
	Grow(list3);
	for (int i : list3)cout << i << tab; cout << endl;

	List<std::string>s_list = { "Хорошо","живет","на","свете","Винни","Пух" };
	for (std::string i : s_list)cout << i << tab; cout << endl;

	List<double>d_list = { 2.7,3.14,5.4,8.3 };
	for (double i : d_list)cout << i << tab; cout << endl;
	d_list.print();

	List<std::string>b_list = { "Хорошо","Живет","на","свете","ноут","бук" };
	for (std::string i : b_list)cout << i << tab; cout << endl;
}

    //вид 34 ООП
//                    Двусвязный список
//Двусвязным называется список - каждый элемент которого хранит адрес не только следущего но и предыдущего элемента. т.е у него есть кроме pNext есть еще pPrev(хранит адрес предыдущего элемента) Это позволяет ходить по списку в обоих направлениях как от начала до конца так и от конца к началу. Такая возможность уменьшает время доступа к элементу в два раза, но делает список более тяжелым по скольку каждый элемент хранит больше служебной информации. 

// У двусвязного списка кроме головы которая указывает на начальный элемент списка, есть еще и хвост Tail - который указывает на последний элемент списка. В двусвязный список можно зайти как и через голову так и через хвост, если список пуст его голова и хвост указывают на ноль. Если список содержит один единственный элемент он одновременно является и головой и хвостом списка. А так же он является и первым и последний элемент списка с какой стороны не посмотреть.

// В отдельном проекте реализовать двусвязный список

//композиция и агрегирование - на данный момент композиция 

//35 2_07
//1 insert() / erase();
//2  Оптимизировать общий случай добавления элементов до одного выражения;
//3 создать Commit

// 37 видео 2/45
//добить итераторы

// Выражение Start выполняется 1 раз- перед первой итерацией;
// видео 38 1.44


                       // Шаблоны классов
// Шаблонным называется класс тип полей которого определяетя при создании обьекта т.е поля шаблонного класса могут быть любого типа. При обращении к шаблонному классу обязательно нужно указывать тип его членов явным образом т.е если к обыченому классу мы обращаемся так Class - обычный класс, то к шаблонному классу обращаемся так Class<type> - шаблон. Причем тип может быть как шаблонный так и конкретный Class<double> . Все методы внутри  шаблонном классе автоматически становятся шаблоннымы 
// Для того что бы сделать класс шаблонным перед ним достаточно просто создать шаблон
 // template - показывает создание шаблони 
// typenem - создание шаблонного тип данных
// T - имя шаблонного типа
//     Если внутри шаблонного класса созданы другие классы то они являются не шаблонными а обычными классами, но любую переменную член и любой метод такого вложенного класса можно сделать шаблонными 

// 39 видео 15 min
// 40 ёёёёёёёёёёёёёёёёёёёёёёёёёёёёёёёёё
// constIterator = конструктор

//Параметры по умолчанию могут быть только в прототипах функций (ConstIterator(Element* Temp = nullptr))ConstIterator(Element* Temp)
//
//
// 41 video 1.28


